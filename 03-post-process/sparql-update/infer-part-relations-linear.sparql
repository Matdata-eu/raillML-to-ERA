PREFIX era: <http://data.europa.eu/949/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

# Infer era:isPartOf / era:hasPart relations for linear child elements (tracks)
#
# Context:
#   ERA SHACL requires that linear elements (RunningTrack, Siding) are declared as
#   parts of the aggregate elements they physically fall within:
#     track era:isPartOf operationalPoint / sectionOfLine  (child → parent)
#     operationalPoint / sectionOfLine era:hasPart track   (parent → child, inverse)
#
#   Both master and child elements are positioned via NetLinearReference, which
#   spans a sequence of net elements with a declared start and end offset.
#   Masters may alternatively use a NetAreaReference that includes a list of
#   NetLinearReferences.
#
# Matching logic:
#   1. Find master parts of type OperationalPoint or SectionOfLine, with either:
#        a. a direct NetLinearReference, or
#        b. a NetAreaReference whose rdf:list includes NetLinearReferences.
#   2. For each NetLinearReference of the master, traverse its sequence of net
#      elements and determine the effective start/end offset on each element:
#        - If it is the first element, use the declared start offset; else 0.
#        - If it is the last element, use the declared end offset; else element length.
#   3. Find child elements of type RunningTrack or Siding (excluding the master's own
#      type to avoid self-containment) whose NetLinearReference sequence also includes
#      the same net element.
#   4. Compute the child's effective window on that element using the same rule.
#   5. Assert the part relation when the child's window overlaps with the master's
#      window on the shared net element (start or end of child falls within master).

INSERT {
  ?childElement era:isPartOf ?masterPart .
  ?masterPart era:hasPart ?childElement .
}
WHERE {
  VALUES ?masterPartType { era:OperationalPoint era:SectionOfLine }
  {
    # Define master part types (parent elements that contain other elements)
    ?masterPart a ?masterPartType .
    ?masterPart era:netReference ?masterNetLinRef .
    ?masterNetLinRef a era:NetLinearReference .
  }
  UNION
  {
    ?masterPart a ?masterPartType .
    ?masterPart era:netReference ?masterNetAreaRef .
    ?masterNetAreaRef a era:NetAreaReference ;
                      era:includes ?includeList .
    ?includeList rdf:rest*/rdf:first ?masterNetLinRef .
  }
  
  # The track's net reference covers a sequence of net elements
  ?masterNetLinRef a era:NetLinearReference ;
                   era:hasSequence ?sequenceList ;
                   era:startsAt/era:hasTopoCoordinate ?firstNetElementStartPoint ;
                   era:endsAt/era:hasTopoCoordinate ?lastNetElementEndPoint .

  # The OP's linearElement must appear somewhere in the track's sequence
  ?sequenceList rdf:rest*/rdf:first ?linearElement .
  
  # Needed to default end offset when this element is not the last in the sequence
  ?linearElement era:lengthOfNetLinearElement ?netElementMaxPos .

  # Resolve the track's declared start/end coordinates for boundary checking
  ?firstNetElementStartPoint a era:TopologicalCoordinate ;
                             era:onLinearElement ?firstLinearElement ;
                             era:offsetFromOrigin ?firstLinearElementStartPointPos .
  ?lastNetElementEndPoint a era:TopologicalCoordinate ;
                          era:onLinearElement ?lastLinearElement ;
                          era:offsetFromOrigin ?lastLinearElementEndPointPos .

  # Effective window of the track on this specific net element:
  #   start = track's offset if this is the first element, else 0
  #   end   = track's offset if this is the last element,  else element length
  BIND (IF(?linearElement = ?firstLinearElement, ?firstLinearElementStartPointPos, 0) AS ?masterStartPointOnThisNetElement)
  BIND (IF(?linearElement = ?lastLinearElement, ?lastLinearElementEndPointPos, ?netElementMaxPos) AS ?masterEndPointOnThisNetElement)

  # CASE B: Linear elements
  # Linear elements are part of master when their extents overlap
  VALUES ?linearType { era:RunningTrack era:Siding }
  ?childElement a ?linearType ;
                era:netReference ?childNetRef .

  # Filter to linear element types
  FILTER (?linearType != ?masterPartType)
  
  # Get child element's extent  
  # The child's net reference covers a sequence of net elements
  ?childNetRef a era:NetLinearReference ;
                   era:hasSequence ?childSequenceList ;
                   era:startsAt/era:hasTopoCoordinate ?firstChildNetElementStartPoint ;
                   era:endsAt/era:hasTopoCoordinate ?lastChildNetElementEndPoint .

  # The OP's linearElement must appear somewhere in the track's sequence
  ?childSequenceList rdf:rest*/rdf:first ?linearElement .

  # Resolve the child's declared start/end coordinates for boundary checking
  ?firstChildNetElementStartPoint a era:TopologicalCoordinate ;
                             era:onLinearElement ?firstChildLinearElement ;
                             era:offsetFromOrigin ?firstChildLinearElementStartPointPos .
  ?lastChildNetElementEndPoint a era:TopologicalCoordinate ;
                          era:onLinearElement ?lastChildLinearElement ;
                          era:offsetFromOrigin ?lastChildLinearElementEndPointPos .

  # Effective window of the track on this specific net element:
  #   start = child's offset if this is the first element, else 0
  #   end   = child's offset if this is the last element,  else element length
  BIND (IF(?linearElement = ?firstChildLinearElement, ?firstChildLinearElementStartPointPos, 0) AS ?childStartPointOnThisNetElement)
  BIND (IF(?linearElement = ?lastChildLinearElement, ?lastChildLinearElementEndPointPos, ?netElementMaxPos) AS ?childEndPointOnThisNetElement)
  
  # Child needs to overlap with parent on this netElement
  FILTER (
    (   ?childStartPointOnThisNetElement >= ?masterStartPointOnThisNetElement 
        && ?childStartPointOnThisNetElement <= ?masterEndPointOnThisNetElement) 
    || 
    (   ?childEndPointOnThisNetElement >= ?masterStartPointOnThisNetElement 
        && ?childEndPointOnThisNetElement <= ?masterEndPointOnThisNetElement)
  )
}